<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=true"></script>
<!-- End Tencent Analysis -->


    



    <meta charset="utf-8">
    
    
    
    
    <title>JS学习之RegExp对象 | HeJL | just,Try!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="正则表达式对象">
    <meta name="description" content="概述两种方式表达正则表达式一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp(&apos;xyz&apos;); RegExp构造函数还可以接受第二个参数，表示修饰符。 实例属性 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。 RegExp.prototy">
<meta name="keywords" content="正则表达式对象">
<meta property="og:type" content="article">
<meta property="og:title" content="JS学习之RegExp对象">
<meta property="og:url" content="http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/index.html">
<meta property="og:site_name" content="HeJL">
<meta property="og:description" content="概述两种方式表达正则表达式一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp(&apos;xyz&apos;); RegExp构造函数还可以接受第二个参数，表示修饰符。 实例属性 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。 RegExp.prototy">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-01T17:44:58.187Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS学习之RegExp对象">
<meta name="twitter:description" content="概述两种方式表达正则表达式一种是使用字面量，以斜杠表示开始和结束。 1var regex = /xyz/; 另一种是使用RegExp构造函数。 1var regex = new RegExp(&apos;xyz&apos;); RegExp构造函数还可以接受第二个参数，表示修饰符。 实例属性 RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。 RegExp.prototy">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HeJL</h5>
          <a href="mailto:1047867332@qq.com" title="1047867332@qq.com" class="mail">1047867332@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Hedroins" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/dream"  >
                <i class="icon icon-lg icon-dream"></i>
                Dream
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JS学习之RegExp对象</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JS学习之RegExp对象</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-21T06:21:17.000Z" itemprop="datePublished" class="page-time">
  2019-07-21
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#两种方式表达正则表达式"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">两种方式表达正则表达式</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#实例属性"><span class="post-toc-number">2.</span> <span class="post-toc-text">实例属性</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#实例方法"><span class="post-toc-number">3.</span> <span class="post-toc-text">实例方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RegExp-prototype-test-返回一个布尔值表示当前模式是否匹配参数字符串"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">RegExp.prototype.test() 返回一个布尔值表示当前模式是否匹配参数字符串</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RegExp-prototype-exec-如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">RegExp.prototype.exec() 如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组匹配"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">组匹配</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#字符串的实例方法"><span class="post-toc-number">4.</span> <span class="post-toc-text">字符串的实例方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#String-prototype-match-对字符串进行正则匹配，返回匹配结果"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">String.prototype.match() 对字符串进行正则匹配，返回匹配结果</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#String-prototype-search-返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">String.prototype.search()返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#String-prototype-replace-方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">String.prototype.replace()方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#String-prototype-split-按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">String.prototype.split()按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#匹配规则"><span class="post-toc-number">5.</span> <span class="post-toc-text">匹配规则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字面变量"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">字面变量</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#元字符"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">元字符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#点字符（-匹配除回车（-r）、换行-n-、行分隔符（-u2028）和段分隔符（-u2029）以外的所有字符。"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">点字符（.) 匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#位置字符（"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">位置字符（^,$)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择符（-）"><span class="post-toc-number">5.2.3.</span> <span class="post-toc-text">选择符（|）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#转义符（"><span class="post-toc-number">5.2.4.</span> <span class="post-toc-text">转义符（\)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#特殊字符"><span class="post-toc-number">5.2.5.</span> <span class="post-toc-text">特殊字符</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#字符类（"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">字符类（[])</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#脱字符（-）表示除了字符类之中的字符，其他字符都可以匹配。比如，-xyz-表示除了x、y、z之外都可以匹配。"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">脱字符（^ ）表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#连字符-对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">连字符(-) 对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#预定义模式"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">预定义模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通常，正则表达式遇到换行符（-n）就会停止匹配。"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">通常，正则表达式遇到换行符（\n）就会停止匹配。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重复类（-）"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">重复类（{}）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#量词符（？，-，-）"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">量词符（？，*，+）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#修饰符-（i-m-g"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">修饰符 （i,m,g)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。"><span class="post-toc-number">5.7.1.</span> <span class="post-toc-text">g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）"><span class="post-toc-number">5.7.2.</span> <span class="post-toc-text">i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#m修饰符：会修改-和-的行为。默认情况下（即不加m修饰符时），-和-匹配字符串的开始处和结尾处，加上m修饰符以后，-和-还会匹配行首和行尾，即-和-会识别换行符（-n）"><span class="post-toc-number">5.7.3.</span> <span class="post-toc-text">m修饰符：会修改^和###  的行为。默认情况下（即不加m修饰符时），^和###  匹配字符串的开始处和结尾处，加上m修饰符以后，^和###  还会匹配行首和行尾，即^和###  会识别换行符（\n）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#组匹配-1"><span class="post-toc-number">5.8.</span> <span class="post-toc-text">组匹配</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正则表达式内部，还可以用-n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。"><span class="post-toc-number">5.9.</span> <span class="post-toc-text">正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#非捕获组：-x-称为非捕获组（Non-capturing-group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。"><span class="post-toc-number">5.9.1.</span> <span class="post-toc-text">非捕获组：(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#先行断言：x-y-称为先行断言（Positive-look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成-d"><span class="post-toc-number">5.9.2.</span> <span class="post-toc-text">先行断言：x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#先行否定断言：x-y-称为先行否定断言（Negative-look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成-d"><span class="post-toc-number">5.9.3.</span> <span class="post-toc-text">先行否定断言：x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JS学习之RegExp对象"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JS学习之RegExp对象</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-21 14:21:17" datetime="2019-07-21T06:21:17.000Z"  itemprop="datePublished">2019-07-21</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="两种方式表达正则表达式"><a href="#两种方式表达正则表达式" class="headerlink" title="两种方式表达正则表达式"></a>两种方式表达正则表达式</h2><p>一种是使用字面量，以斜杠表示开始和结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>;</span><br></pre></td></tr></table></figure>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>);</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符。</p>
<h1 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h1><ul>
<li><strong>RegExp.prototype.ignoreCase</strong>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><strong>RegExp.prototype.global</strong>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><strong>RegExp.prototype.multiline</strong>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
</ul>
<p>上面三个属性都是只读的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.ignoreCase <span class="comment">// true</span></span><br><span class="line">r.global <span class="comment">// true</span></span><br><span class="line">r.multiline <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另一类是与修饰符无关的属性，主要是下面两个。</p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。</li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.source <span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="RegExp-prototype-test-返回一个布尔值表示当前模式是否匹配参数字符串"><a href="#RegExp-prototype-test-返回一个布尔值表示当前模式是否匹配参数字符串" class="headerlink" title="RegExp.prototype.test() 返回一个布尔值表示当前模式是否匹配参数字符串"></a>RegExp.prototype.test() 返回一个布尔值表示当前模式是否匹配参数字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/cat/.test(<span class="string">'cats and dogs'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 0</span></span><br><span class="line">r.test(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 2</span></span><br><span class="line">r.test(s) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">r.lastIndex <span class="comment">// 4</span></span><br><span class="line">r.test(s) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>下面这样写是错误的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="regexp">/a/g</span>.test(<span class="string">'babaa'</span>)) count++;</span><br></pre></td></tr></table></figure>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">''</span>).test(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="RegExp-prototype-exec-如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。"><a href="#RegExp-prototype-exec-如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。" class="headerlink" title="RegExp.prototype.exec() 如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。"></a>RegExp.prototype.exec() 如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["x"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h3><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="comment">// ["_x", "x"]</span></span><br></pre></td></tr></table></figure>
<p><code>exec</code>方法的返回数组还包含以下两个属性：</p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：整个模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</span><br><span class="line"><span class="keyword">var</span> arr = r.exec(<span class="string">'_abbba_aba_'</span>);</span><br><span class="line"></span><br><span class="line">arr <span class="comment">// ["abbba", "bbb"]</span></span><br><span class="line"></span><br><span class="line">arr.index <span class="comment">// 1</span></span><br><span class="line">arr.input <span class="comment">// "_abbba_aba_"</span></span><br></pre></td></tr></table></figure>
<p><strong>index属性是exec方法返回数组的属性，lastIndex是正则实例对象的属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc_abc_abc'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = reg.exec(str);</span><br><span class="line">r1 <span class="comment">// ["a"]</span></span><br><span class="line">r1.index <span class="comment">// 0</span></span><br><span class="line">reg.lastIndex <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式加了g（全局属性）则可以匹配多次。如果未声明全局属性则只匹配一次，不会记录下次将要匹配的信息。全局匹配如果搜索到字符串的末端，下一次匹配将从头开始。</p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc_abc_abc'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> match = reg.exec(str);</span><br><span class="line">  <span class="keyword">if</span> (!match) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'#'</span> + match.index + <span class="string">':'</span> + match[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #0:a</span></span><br><span class="line"><span class="comment">// #4:a</span></span><br><span class="line"><span class="comment">// #8:a</span></span><br></pre></td></tr></table></figure>
<p><strong>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配。</strong></p>
<h1 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h1><p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
<h2 id="String-prototype-match-对字符串进行正则匹配，返回匹配结果"><a href="#String-prototype-match-对字符串进行正则匹配，返回匹配结果" class="headerlink" title="String.prototype.match() 对字符串进行正则匹配，返回匹配结果"></a>String.prototype.match() 对字符串进行正则匹配，返回匹配结果</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</span><br><span class="line"></span><br><span class="line">s.match(r1) <span class="comment">// ["x"]</span></span><br><span class="line">s.match(r2) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>。如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'abba'</span>;</span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</span><br><span class="line"></span><br><span class="line">s.match(r) <span class="comment">// ["a", "a"]</span></span><br><span class="line">r.exec(s) <span class="comment">// ["a"]</span></span><br></pre></td></tr></table></figure>
<p><strong>正则表达式的lastIndex属性对正则实例对象的exec方法有效，用于指定下一次匹配的开始位置，但对字符串的match方法无效。对于match方法，匹配总是从字符串的第一个字符开始。</strong></p>
<h2 id="String-prototype-search-返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1"><a href="#String-prototype-search-返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1" class="headerlink" title="String.prototype.search()返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1"></a>String.prototype.search()返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'_x_x'</span>.search(<span class="regexp">/x/</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h2 id="String-prototype-replace-方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。"><a href="#String-prototype-replace-方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。" class="headerlink" title="String.prototype.replace()方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。"></a>String.prototype.replace()方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(search, replacement)</span><br></pre></td></tr></table></figure>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaa'</span>.replace(<span class="string">'a'</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="regexp">/a/</span>, <span class="string">'b'</span>) <span class="comment">// "baa"</span></span><br><span class="line"><span class="string">'aaa'</span>.replace(<span class="regexp">/a/g</span>, <span class="string">'b'</span>) <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'  #id div.class  '</span>;</span><br><span class="line"></span><br><span class="line">str.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment">// "#id div.class"</span></span><br></pre></td></tr></table></figure>
<p><strong><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code></strong>，用来指代所替换的内容。</p>
<ul>
<li>$&amp;：匹配的子字符串。</li>
<li>$`：匹配结果前面的文本。</li>
<li>$’：匹配结果后面的文本。</li>
<li>$n：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数。</li>
<li>$$：指代美元符号<code>$</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2 $1'</span>)</span><br><span class="line"><span class="comment">// "world hello"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.replace(<span class="string">'b'</span>, <span class="string">'[$`-$&amp;-$\']'</span>)</span><br><span class="line"><span class="comment">// "a[a-b-c]c"</span></span><br></pre></td></tr></table></figure>
<p><strong><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'3 and 5'</span>.replace(<span class="regexp">/[0-9]+/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * match;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// "6 and 10"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'The quick brown fox jumped over the lazy dog.'</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</span><br><span class="line"></span><br><span class="line">a.replace(pattern, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> match.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></span><br></pre></td></tr></table></figure>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prices = &#123;</span><br><span class="line">  <span class="string">'p1'</span>: <span class="string">'$1.99'</span>,</span><br><span class="line">  <span class="string">'p2'</span>: <span class="string">'$9.99'</span>,</span><br><span class="line">  <span class="string">'p3'</span>: <span class="string">'$5.00'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> template = <span class="string">'&lt;span id="p1"&gt;&lt;/span&gt;'</span></span><br><span class="line">  + <span class="string">'&lt;span id="p2"&gt;&lt;/span&gt;'</span></span><br><span class="line">  + <span class="string">'&lt;span id="p3"&gt;&lt;/span&gt;'</span>;</span><br><span class="line"></span><br><span class="line">template.replace(</span><br><span class="line">  /(<span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">")(.*?)("</span>&gt;</span>)(<span class="tag">&lt;<span class="name">\</span>/<span class="attr">span</span>&gt;</span></span>)/g,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">match, $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">3</span> + prices[$<span class="number">2</span>] + $<span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// "&lt;span id="p1"&gt;$1.99&lt;/span&gt;&lt;span id="p2"&gt;$9.99&lt;/span&gt;&lt;span id="p3"&gt;$5.00&lt;/span&gt;"</span></span><br></pre></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中。</p>
<h2 id="String-prototype-split-按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。"><a href="#String-prototype-split-按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。" class="headerlink" title="String.prototype.split()按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。"></a>String.prototype.split()按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</h2><p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非正则分隔</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">// [ 'a', '  b', 'c', ' d' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则分隔，去除多余的空格</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>)</span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c', 'd' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定返回数组的最大成员</span></span><br><span class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>, <span class="number">2</span>)</span><br><span class="line">[ <span class="string">'a'</span>, <span class="string">'b'</span> ]</span><br></pre></td></tr></table></figure>
<p>以/,*/正则表达式作为分隔符，则空字符串也可作为分隔符（即0个该字符）</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'aaa*a*'</span>.split(<span class="regexp">/(a*)/</span>)</span><br><span class="line"><span class="comment">// [ '', 'aaa', '*', 'a', '*' ]</span></span><br></pre></td></tr></table></figure>
<h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><h2 id="字面变量"><a href="#字面变量" class="headerlink" title="字面变量"></a>字面变量</h2><p>比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="点字符（-匹配除回车（-r）、换行-n-、行分隔符（-u2028）和段分隔符（-u2029）以外的所有字符。"><a href="#点字符（-匹配除回车（-r）、换行-n-、行分隔符（-u2028）和段分隔符（-u2029）以外的所有字符。" class="headerlink" title="点字符（.) 匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。"></a>点字符（.) 匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。</h3><p>注意，对于码点大于<code>0xFFFF</code>的 Unicode 字符，点字符不能正确匹配，会认为这是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/c.t/</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<h3 id="位置字符（"><a href="#位置字符（" class="headerlink" title="位置字符（^,$)"></a>位置字符（^,$)</h3><p>^ 表示字符串的开始位置</p>
<p>$ 表示字符串的结束位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test必须出现在开始位置</span></span><br><span class="line">/^test/.test(<span class="string">'test123'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test必须出现在结束位置</span></span><br><span class="line">/test$/.test(<span class="string">'new test'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从开始位置到结束位置只有test</span></span><br><span class="line">/^test$/.test(<span class="string">'test'</span>) <span class="comment">// true</span></span><br><span class="line">/^test$/.test(<span class="string">'test test'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="选择符（-）"><a href="#选择符（-）" class="headerlink" title="选择符（|）"></a>选择符（|）</h3><p>表示“或关系”（OR），即cat|dog表示匹配cat或dog。</p>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<p>其他的元字符还包括<code>\\</code>、<code>\*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>{}</code>等，将在下文解释。</p>
<h3 id="转义符（"><a href="#转义符（" class="headerlink" title="转义符（\)"></a>转义符（\)</h3><p>那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>{</code>和<code>\\</code>。需要特别注意的是，<strong>如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'1\+1'</span>)).test(<span class="string">'1+1'</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'1\\+1'</span>)).test(<span class="string">'1+1'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h2 id="字符类（"><a href="#字符类（" class="headerlink" title="字符类（[])"></a>字符类（[])</h2><p>表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.test(<span class="string">'hello world'</span>) <span class="comment">// false</span></span><br><span class="line">/[abc]/.test(<span class="string">'apple'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<h3 id="脱字符（-）表示除了字符类之中的字符，其他字符都可以匹配。比如，-xyz-表示除了x、y、z之外都可以匹配。"><a href="#脱字符（-）表示除了字符类之中的字符，其他字符都可以匹配。比如，-xyz-表示除了x、y、z之外都可以匹配。" class="headerlink" title="脱字符（^ ）表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。"></a>脱字符（^ ）表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.test(<span class="string">'hello world'</span>) <span class="comment">// true</span></span><br><span class="line">/[^abc]/.test(<span class="string">'bbc'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'Please yes\nmake my day!'</span>;</span><br><span class="line"></span><br><span class="line">s.match(<span class="regexp">/yes.*day/</span>) <span class="comment">// null</span></span><br><span class="line">s.match(<span class="regexp">/yes[^]*day/</span>) <span class="comment">// [ 'yes\nmake my day']</span></span><br></pre></td></tr></table></figure>
<h3 id="连字符-对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。"><a href="#连字符-对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。" class="headerlink" title="连字符(-) 对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。"></a>连字符(-) 对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。</h3><p>比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<p>当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义,只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span><span class="number">-9.</span>,]</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>a-fA-F]</span><br><span class="line">[a-zA-Z0<span class="number">-9</span>-]</span><br><span class="line">[<span class="number">1</span><span class="number">-31</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。(连字符只作用于相连接的两个字符表示简写)</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"\u0130\u0131\u0132"</span>;</span><br><span class="line">/[\u0128-\uFFFF]/.test(str)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<h2 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h2><p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \s 的例子</span></span><br><span class="line">/\s\w*<span class="regexp">/.exec('hello world') /</span><span class="regexp">/ [" world"]</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ \b 的例子</span></span><br><span class="line"><span class="regexp">/</span>\bworld/.test(<span class="string">'hello world'</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">'hello-world'</span>) <span class="comment">// true</span></span><br><span class="line">/\bworld/.test(<span class="string">'helloworld'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \B 的例子</span></span><br><span class="line">/\Bworld/.test(<span class="string">'hello-world'</span>) <span class="comment">// false</span></span><br><span class="line">/\Bworld/.test(<span class="string">'helloworld'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界(前面以空格或者，连接符（-）隔开的词），所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<h3 id="通常，正则表达式遇到换行符（-n）就会停止匹配。"><a href="#通常，正则表达式遇到换行符（-n）就会停止匹配。" class="headerlink" title="通常，正则表达式遇到换行符（\n）就会停止匹配。"></a><strong>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">"&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;"</span>;</span><br><span class="line"></span><br><span class="line">/.*<span class="regexp">/.exec(html)[0]</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ "&lt;b&gt;Hello&lt;/</span>b&gt;<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">"&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;"</span>;</span><br><span class="line"></span><br><span class="line">/[\S\s]*<span class="regexp">/.exec(html)[0]</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ "&lt;b&gt;Hello&lt;/</span>b&gt;\n&lt;i&gt;world!<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，[\S\s]指代一切字符，还可以用[^]*也可以指代一切字符。</p>
<h3 id="重复类（-）"><a href="#重复类（-）" class="headerlink" title="重复类（{}）"></a>重复类（{}）</h3><p><strong>模式的精确匹配次数，使用大括号（<code>{}</code>）表示。<code>{n}</code>表示恰好重复<code>n</code>次，<code>{n,}</code>表示至少重复<code>n</code>次，<code>{n,m}</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lo&#123;<span class="number">2</span>&#125;k/.test(<span class="string">'look'</span>) <span class="comment">// true</span></span><br><span class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.test(<span class="string">'looook'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。 如果是首字符重复的话就无法做到精确匹配，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/w&#123;<span class="number">2</span>,<span class="number">3</span>&#125;ok/.test(<span class="string">'wwwwwwwwwok'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码的出现true的原因是，在靠近’ok’的一端取2或3个w也满足要求。除非加上^表示从字符的开始的位置进行匹配，否则 ^和$的情况都会被考录进去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^w&#123;<span class="number">2</span>,<span class="number">3</span>&#125;ok/.test(<span class="string">'wwwwwwwwwok'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="量词符（？，-，-）"><a href="#量词符（？，-，-）" class="headerlink" title="量词符（？，*，+）"></a>量词符（？，*，+）</h2><p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>{0, 1}</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>{0,}</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>{1,}</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t 出现0次或1次</span></span><br><span class="line">/t?est/.test(<span class="string">'test'</span>) <span class="comment">// true</span></span><br><span class="line">/t?est/.test(<span class="string">'est'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现1次或多次</span></span><br><span class="line">/t+est/.test(<span class="string">'test'</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.test(<span class="string">'ttest'</span>) <span class="comment">// true</span></span><br><span class="line">/t+est/.test(<span class="string">'est'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t 出现0次或多次</span></span><br><span class="line">/t*est/.test(<span class="string">'test'</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">'ttest'</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">'tttest'</span>) <span class="comment">// true</span></span><br><span class="line">/t*est/.test(<span class="string">'est'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。"><a href="#贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。" class="headerlink" title="贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。"></a>贪婪模式：量词符默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa'</span>;</span><br><span class="line">s.match(<span class="regexp">/a+/</span>) <span class="comment">// ["aaa"]</span></span><br></pre></td></tr></table></figure>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa'</span>;</span><br><span class="line">s.match(<span class="regexp">/a+?/</span>) <span class="comment">// ["a"]</span></span><br></pre></td></tr></table></figure>
<p>一旦条件满足，就不再往下匹配。</p>
<p>除了非贪婪模式的加号，还有非贪婪模式的星号（<code>*</code>）。</p>
<ul>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
</ul>
<h2 id="修饰符-（i-m-g"><a href="#修饰符-（i-m-g" class="headerlink" title="修饰符 （i,m,g)"></a>修饰符 （i,m,g)</h2><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/ig</span>;</span><br></pre></td></tr></table></figure>
<h3 id="g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。"><a href="#g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。" class="headerlink" title="g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。"></a>g修饰符：默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</h3><p>（1）不加g修饰符的匹配，每次都从头开始</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abba'</span>;</span><br><span class="line"></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>（2）加了g修饰符的匹配，每次都是从上一次匹配成功处，开始向后匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abba'</span>;</span><br><span class="line"></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// true</span></span><br><span class="line">regex.test(str); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）"><a href="#i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）" class="headerlink" title="i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）"></a>i修饰符：加上i修饰符以后表示忽略大小写（ignorecase）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(<span class="string">'ABC'</span>) <span class="comment">// false</span></span><br><span class="line">/abc/i.test(<span class="string">'ABC'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<h3 id="m修饰符：会修改-和-的行为。默认情况下（即不加m修饰符时），-和-匹配字符串的开始处和结尾处，加上m修饰符以后，-和-还会匹配行首和行尾，即-和-会识别换行符（-n）"><a href="#m修饰符：会修改-和-的行为。默认情况下（即不加m修饰符时），-和-匹配字符串的开始处和结尾处，加上m修饰符以后，-和-还会匹配行首和行尾，即-和-会识别换行符（-n）" class="headerlink" title="m修饰符：会修改^和###  的行为。默认情况下（即不加m修饰符时），^和###  匹配字符串的开始处和结尾处，加上m修饰符以后，^和###  还会匹配行首和行尾，即^和###  会识别换行符（\n）"></a>m修饰符：会修改<code>^</code>和<code>###  的行为。默认情况下（即不加</code>m<code>修饰符时），</code>^<code>和</code>###  匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>###  还会匹配行首和行尾，即</code>^<code>和</code>###  会识别换行符（<code>\n</code>）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.test(<span class="string">'hello world\n'</span>) <span class="comment">// false</span></span><br><span class="line">/world$/m.test(<span class="string">'hello world\n'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^b/m.test(<span class="string">'a\nb'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h2 id="组匹配-1"><a href="#组匹配-1" class="headerlink" title="组匹配"></a>组匹配</h2><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred+<span class="regexp">/.test('fredd') /</span><span class="regexp">/ true</span></span><br><span class="line"><span class="regexp">/</span>(fred)+<span class="regexp">/.test('fredfred') /</span><span class="regexp">/ true</span></span><br></pre></td></tr></table></figure>
<p>下面是另外一个分组捕获的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">'abcabc'</span>.match(<span class="regexp">/(.)b(.)/</span>);</span><br><span class="line">m</span><br><span class="line"><span class="comment">// ['abc', 'a', 'c']</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">'abcabc'</span>.match(<span class="regexp">/(.)b(.)/g</span>);</span><br><span class="line">m <span class="comment">// ['abc', 'abc']</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abcabc'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(.)b(.)/g</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = reg.exec(str);</span><br><span class="line">  <span class="keyword">if</span> (!result) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["abc", "a", "c"]</span></span><br><span class="line"><span class="comment">// ["abc", "a", "c"]</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式内部，还可以用-n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。"><a href="#正则表达式内部，还可以用-n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。" class="headerlink" title="正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。"></a>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(.)b(.)\<span class="number">1</span>b\<span class="number">2</span>/.test(<span class="string">"abcabc"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/y(..)(.)\<span class="number">2</span>\<span class="number">1</span>/.test(<span class="string">'yabccab'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>括号还可以嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/y((..)\<span class="number">2</span>)\<span class="number">1</span>/.test(<span class="string">'yabababab'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tagName = <span class="regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;</span><br><span class="line"></span><br><span class="line">tagName.exec(<span class="string">"&lt;b&gt;bold&lt;/b&gt;"</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">'&lt;b class="hello"&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;'</span>;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// "b"</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// " class="hello""</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// "Hello"</span></span><br><span class="line"></span><br><span class="line">match = tag.exec(html);</span><br><span class="line"></span><br><span class="line">match[<span class="number">1</span>] <span class="comment">// "i"</span></span><br><span class="line">match[<span class="number">2</span>] <span class="comment">// ""</span></span><br><span class="line">match[<span class="number">3</span>] <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>
<h3 id="非捕获组：-x-称为非捕获组（Non-capturing-group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。"><a href="#非捕获组：-x-称为非捕获组（Non-capturing-group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。" class="headerlink" title="非捕获组：(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。"></a>非捕获组：<code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</h3><p>请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">'abc'</span>.match(<span class="regexp">/(?:.)b(.)/</span>);</span><br><span class="line">m <span class="comment">// ["abc", "c"]</span></span><br></pre></td></tr></table></figure>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.exec(<span class="string">'http://google.com/'</span>);</span><br><span class="line"><span class="comment">// ["http://google.com/", "http", "google.com", "/"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非捕获组匹配</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</span><br><span class="line"></span><br><span class="line">url.exec(<span class="string">'http://google.com/'</span>);</span><br><span class="line"><span class="comment">// ["http://google.com/", "google.com", "/"]</span></span><br></pre></td></tr></table></figure>
<h3 id="先行断言：x-y-称为先行断言（Positive-look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成-d"><a href="#先行断言：x-y-称为先行断言（Positive-look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成-d" class="headerlink" title="先行断言：x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/"></a>先行断言：<code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code></h3><p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">'abc'</span>.match(<span class="regexp">/b(?=c)/</span>);</span><br><span class="line">m <span class="comment">// ["b"]</span></span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<h3 id="先行否定断言：x-y-称为先行否定断言（Negative-look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成-d"><a href="#先行否定断言：x-y-称为先行否定断言（Negative-look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成-d" class="headerlink" title="先行否定断言：x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/"></a>先行否定断言：<code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(<span class="string">'3.14'</span>)</span><br><span class="line"><span class="comment">// ["14"]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="string">'abd'</span>.match(<span class="regexp">/b(?!c)/</span>);</span><br><span class="line">m <span class="comment">// ['b']</span></span><br></pre></td></tr></table></figure>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-01T17:44:58.187Z" itemprop="dateUpdated">2019-08-02 01:44:58</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/07/21/JS学习之RegExp对象/" target="_blank" rel="external">http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/</a>
        
    </div>
    
    <footer>
        <a href="http://hedroins.github.io">
            <img src="/img/avatar.jpg" alt="HeJL">
            HeJL
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/正则表达式对象/">正则表达式对象</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&title=《JS学习之RegExp对象》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&title=《JS学习之RegExp对象》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之RegExp对象》 — HeJL&url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/07/22/JS学习之JSON对象/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JS学习之JSON对象</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/07/20/JS学习之Date对象/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JS学习之Date对象</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>HeJL &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&title=《JS学习之RegExp对象》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&title=《JS学习之RegExp对象》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之RegExp对象》 — HeJL&url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://hedroins.github.io/2019/07/21/JS学习之RegExp对象/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
