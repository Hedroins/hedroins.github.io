<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=true"></script>
<!-- End Tencent Analysis -->


    



    <meta charset="utf-8">
    
    
    
    
    <title>JS学习之事件模型 | HeJL | just,Try!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="事件模型">
    <meta name="description" content="EventTarget接口DOM 的事件操作（监听和触发），都定义在EventTarget接口 所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会">
<meta name="keywords" content="事件模型">
<meta property="og:type" content="article">
<meta property="og:title" content="JS学习之事件模型">
<meta property="og:url" content="http://hedroins.github.io/2019/08/09/JS学习之事件模型/index.html">
<meta property="og:site_name" content="HeJL">
<meta property="og:description" content="EventTarget接口DOM 的事件操作（监听和触发），都定义在EventTarget接口 所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-10T09:09:08.022Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS学习之事件模型">
<meta name="twitter:description" content="EventTarget接口DOM 的事件操作（监听和触发），都定义在EventTarget接口 所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。 EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HeJL</h5>
          <a href="mailto:1047867332@qq.com" title="1047867332@qq.com" class="mail">1047867332@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Hedroins" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/dream"  >
                <i class="icon icon-lg icon-dream"></i>
                Dream
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JS学习之事件模型</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JS学习之事件模型</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-09T02:21:21.000Z" itemprop="datePublished" class="page-time">
  2019-08-09
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#EventTarget接口"><span class="post-toc-number">1.</span> <span class="post-toc-text">EventTarget接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EventTarget-addEventListener-用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关于参数的注意事项"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">关于参数的注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EventTarget-removeEventListener-用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">EventTarget.removeEventListener()用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EventTarget-dispatchEvent-在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event-preventDefault-，则返回值为false，否则为true。"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">EventTarget.dispatchEvent()在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#监听函数：对事件作出反应"><span class="post-toc-number">2.</span> <span class="post-toc-text">监听函数：对事件作出反应</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTML的on-属性"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">HTML的on-属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#元素节点的事件属性"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">元素节点的事件属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EventTarget-addEventListener"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">EventTarget.addEventListener()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#小结"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#this的指向"><span class="post-toc-number">3.</span> <span class="post-toc-text">this的指向</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#事件的传播"><span class="post-toc-number">4.</span> <span class="post-toc-text">事件的传播</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一个例子"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">一个例子</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#事件的代理：父节点的监听函数统一处理多个子元素的事件"><span class="post-toc-number">5.</span> <span class="post-toc-text">事件的代理：父节点的监听函数统一处理多个子元素的事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#阻止事件传播：stopPropagation方法"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">阻止事件传播：stopPropagation方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#立即阻止事件传播：stopImmediatePropagation方法"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">立即阻止事件传播：stopImmediatePropagation方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Event对象概述"><span class="post-toc-number">6.</span> <span class="post-toc-text">Event对象概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Event对象本身就是一个构造函数，可以用来生成新的实例。"><span class="post-toc-number">6.0.0.1.</span> <span class="post-toc-text">Event对象本身就是一个构造函数，可以用来生成新的实例。</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Event对象的实例属性"><span class="post-toc-number">7.</span> <span class="post-toc-text">Event对象的实例属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-bubbles属性返回一个布尔值，表示当前事件是否会冒泡。"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-cancelBubble属性是一个布尔值，如果设为true，相当于执行Event-stopPropagation-，可以阻止事件的传播。"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event-preventDefault方法。该属性只读。"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-Target属性返回原始触发事件的那个节点，即事件最初发生的节点。"><span class="post-toc-number">7.7.</span> <span class="post-toc-text">Event.Target属性返回原始触发事件的那个节点，即事件最初发生的节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。"><span class="post-toc-number">7.8.</span> <span class="post-toc-text">Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-detail属性只有浏览器的-UI-（用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。"><span class="post-toc-number">7.9.</span> <span class="post-toc-text">Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Event对象的实例方法"><span class="post-toc-number">8.</span> <span class="post-toc-text">Event对象的实例方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-preventDefault-取消浏览器对当前事件的默认行为"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">Event.preventDefault()取消浏览器对当前事件的默认行为</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-stopPropagation-方法阻止事件在-DOM-中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">Event.stopPropagation()方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">Event.stopImmediatePropagation()阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点.</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Event-composedPath-返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CustomEvent接口：用于生成自定义的事件实例"><span class="post-toc-number">9.</span> <span class="post-toc-text">CustomEvent接口：用于生成自定义的事件实例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#浏览器原生提供CustomEvent-构造函数，用来生成-CustomEvent-事件实例。"><span class="post-toc-number">9.0.0.1.</span> <span class="post-toc-text">浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JS学习之事件模型"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JS学习之事件模型</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-09 10:21:21" datetime="2019-08-09T02:21:21.000Z"  itemprop="datePublished">2019-08-09</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="EventTarget接口"><a href="#EventTarget接口" class="headerlink" title="EventTarget接口"></a>EventTarget接口</h1><p><strong>DOM 的事件操作（监听和触发），都定义在<code>EventTarget</code>接口</strong></p>
<p><strong>所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</strong></p>
<h2 id="EventTarget-addEventListener-用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。"><a href="#EventTarget-addEventListener-用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。" class="headerlink" title="EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。"></a>EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>type</code>：事件名称，大小写敏感。</strong></li>
<li><strong><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</strong></li>
<li><strong><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为<code>false</code>（<u>监听函数只在冒泡阶段被触发</u>）。该参数可选。</strong></li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>button</code>节点的<code>addEventListener</code>方法绑定<code>click</code>事件的监听函数<code>hello</code>，该函数只在冒泡阶段触发。</p>
<h3 id="关于参数的注意事项"><a href="#关于参数的注意事项" class="headerlink" title="关于参数的注意事项"></a>关于参数的注意事项</h3><p><strong>首先，第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buttonElement.addEventListener(<span class="string">'click'</span>, &#123;</span><br><span class="line">  handleEvent: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>其次，第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。该对象有以下属性。</strong></p>
<blockquote>
<ul>
<li><strong><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</strong></li>
<li><strong><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</strong></li>
<li><strong><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</strong></li>
</ul>
</blockquote>
<p><u><code>addEventListener</code>方法可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。</u></p>
<p><u>如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用<code>removeEventListener</code>方法手动去除）</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>执行上面代码，点击文档只会输出一行<code>Hello world</code>。</p>
<p><strong>如果希望向监听函数传递参数，可以用匿名函数包装一下监听函数。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; print(<span class="string">'Hello'</span>); &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码通过匿名函数，向监听函数<code>print</code>传递了一个参数Hello字符串。</p>
<p><strong>监听函数内部的<code>this</code>，指向当前事件所在的那个对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id="para"&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.getElementById(<span class="string">'para'</span>);</span><br><span class="line">para.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.nodeName); <span class="comment">// "P"</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，监听函数内部的<code>this</code>指向事件所在的对象<code>para</code>。</p>
<h2 id="EventTarget-removeEventListener-用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。"><a href="#EventTarget-removeEventListener-用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。" class="headerlink" title="EventTarget.removeEventListener()用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。"></a>EventTarget.removeEventListener()用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">'click'</span>, listener, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>removeEventListener</code>方法的参数，与<code>addEventListener</code>方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p><u>注意，<code>removeEventListener</code>方法移除的监听函数，必须是<code>addEventListener</code>方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">div.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>removeEventListener</code>方法无效，<strong>因为监听函数不是同一个匿名函数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'mousedown'</span>, handleMouseDown, <span class="literal">true</span>);</span><br><span class="line">element.removeEventListener(<span class="string">"mousedown"</span>, handleMouseDown, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>removeEventListener</code>方法也是无效的，因为第三个参数不一样。</p>
<h2 id="EventTarget-dispatchEvent-在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event-preventDefault-，则返回值为false，否则为true。"><a href="#EventTarget-dispatchEvent-在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event-preventDefault-，则返回值为false，否则为true。" class="headerlink" title="EventTarget.dispatchEvent()在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。"></a>EventTarget.dispatchEvent()在当前节点上触发指定事件，从而触发监听函数的执行。<u>该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</u></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure>
<p><strong><code>dispatchEvent</code>方法的参数是一个<code>Event</code>对象的实例（详见《Event 对象》章节）。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">para.addEventListener(<span class="string">'click'</span>, hello, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'click'</span>);</span><br><span class="line">para.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>上面代码在当前节点触发了<code>click</code>事件。</p>
<p><u>如果<code>dispatchEvent</code>方法的参数为空，或者不是一个有效的事件对象，将报错。</u></p>
<p>下面代码根据<code>dispatchEvent</code>方法的返回值，判断事件是否被取消了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canceled = !cb.dispatchEvent(event);</span><br><span class="line"><span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件取消'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'事件未取消'</span>);</span><br><span class="line">&#125;  <span class="comment">//说明调用Event.preventDefault()说明事件取消</span></span><br></pre></td></tr></table></figure>
<h1 id="监听函数：对事件作出反应"><a href="#监听函数：对事件作出反应" class="headerlink" title="监听函数：对事件作出反应"></a>监听函数：对事件作出反应</h1><p>事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。</p>
<p><strong>JavaScript 有三种方法，可以为事件绑定监听函数。</strong></p>
<h2 id="HTML的on-属性"><a href="#HTML的on-属性" class="headerlink" title="HTML的on-属性"></a>HTML的on-属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=<span class="string">"doSomething()"</span>&gt;</span><br><span class="line">&lt;div onclick=<span class="string">"console.log('触发事件')"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码为<code>body</code>节点的<code>load</code>事件、<code>div</code>节点的<code>click</code>事件，指定了监听代码。一旦事件发生，就会执行这段代码。</p>
<p>元素的事件监听属性，都是<code>on</code>加上事件名，比如<code>onload</code>就是<code>on + load</code>，表示<code>load</code>事件的监听代码。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"doSomething()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"doSomething"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用这个方法指定的监听代码，只会在冒泡阶段触发。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">"console.log(2)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"console.log(1)"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>&lt;button&gt;</code>是<code>&lt;div&gt;</code>的子元素。<code>&lt;button&gt;</code>的<code>click</code>事件，也会触发<code>&lt;div&gt;</code>的<code>click</code>事件。由于<code>on-</code>属性的监听代码，只在冒泡阶段触发，所以点击结果是先输出<code>1</code>，再输出<code>2</code>，<strong>即事件从子元素开始冒泡到父元素。</strong></p>
<h2 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething;</span><br><span class="line"></span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'触发事件'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。</strong></p>
<p><strong>注意，这种方法与 HTML 的<code>on-</code>属性的差异是，它的值是函数名（<code>doSomething</code>），而不像后者，必须给出完整的监听代码（<code>doSomething()</code>）。</strong></p>
<h2 id="EventTarget-addEventListener"><a href="#EventTarget-addEventListener" class="headerlink" title="EventTarget.addEventListener()"></a>EventTarget.addEventListener()</h2><p>所有 DOM 节点实例都有<code>addEventListener</code>方法，用来为该节点定义事件的监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, doSomething, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面三种方法，第一种“HTML 的 on- 属性”，违反了 HTML 与 JavaScript 代码相分离的原则，将两者写在一起，不利于代码分工，因此不推荐使用。</p>
<p>第二种“元素节点的事件属性”的缺点在于，同一个事件只能定义一个监听函数，也就是说，如果定义两次<code>onclick</code>属性，后一次定义会覆盖前一次。因此，也不推荐使用。</p>
<p>第三种<code>EventTarget.addEventListener</code>是推荐的指定监听函数的方法。它有如下优点：</p>
<ul>
<li>同一个事件可以添加多个监听函数。</li>
<li>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数。</li>
<li>除了 DOM 节点，其他对象（比如<code>window</code>、<code>XMLHttpRequest</code>等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口。</li>
</ul>
<h1 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h1><p><strong>监听函数内部的<code>this</code>指向触发事件的那个元素节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span> onclick=<span class="string">"console.log(this.id)"</span>&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>其他两种监听函数的写法，<code>this</code>的指向也是如此。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;button id="btn"&gt;点击&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line">btn.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面两种写法，点击按钮以后也是输出<code>btn</code>。</p>
<h1 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h1><p><strong>一个事件发生后，会在子元素和父元素之间传播（propagation）</strong></p>
<p>这种传播分成三个阶段。</p>
<ul>
<li><strong>第一阶段</strong>：<u>从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）</u>。</li>
<li><strong>第二阶段</strong>：<u>在目标节点上触发，称为“目标阶段”（target phase）。</u></li>
<li><strong>第三阶段</strong>：<u>从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</u></li>
</ul>
<p><strong>这种三阶段的传播模型，使得同一个事件会在多个节点上触发。</strong></p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果对这两个节点，都设置<code>click</code>事件的监听函数（每个节点的捕获阶段和监听阶段，各设置一个监听函数），共计设置四个监听函数。然后，对<code>&lt;p&gt;</code>点击，<code>click</code>事件会触发四次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phases = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="string">'capture'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'target'</span>,</span><br><span class="line">  <span class="number">3</span>: <span class="string">'bubble'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, callback, <span class="literal">true</span>);</span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, callback, <span class="literal">true</span>);</span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, callback, <span class="literal">false</span>);</span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="keyword">var</span> phase = phases[event.eventPhase];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Tag: '"</span> + tag + <span class="string">"'. EventPhase: '"</span> + phase + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击以后的结果</span></span><br><span class="line"><span class="comment">// Tag: 'DIV'. EventPhase: 'capture'</span></span><br><span class="line"><span class="comment">// Tag: 'P'. EventPhase: 'target'</span></span><br><span class="line"><span class="comment">// Tag: 'P'. EventPhase: 'target'</span></span><br><span class="line"><span class="comment">// Tag: 'DIV'. EventPhase: 'bubble'</span></span><br></pre></td></tr></table></figure>
<ol>
<li>捕获阶段：事件从<code>&lt;div&gt;</code>向<code>&lt;p&gt;</code>传播时，触发<code>&lt;div&gt;</code>的<code>click</code>事件；</li>
<li>目标阶段：事件从<code>&lt;div&gt;</code>到达<code>&lt;p&gt;</code>时，触发<code>&lt;p&gt;</code>的<code>click</code>事件；</li>
<li>冒泡阶段：事件从<code>&lt;p&gt;</code>传回<code>&lt;div&gt;</code>时，再次触发<code>&lt;div&gt;</code>的<code>click</code>事件。</li>
</ol>
<p>注意，浏览器总是假定<code>click</code>事件的目标节点，就是点击位置嵌套最深的那个节点（本例是<code>&lt;div&gt;</code>节点里面的<code>&lt;p&gt;</code>节点）。所以，<code>&lt;p&gt;</code>节点的捕获阶段和冒泡阶段，<strong>都会显示为<code>target</code>阶段。</strong>   <strong>但是事件传播的方向还是有区别的。</strong></p>
<p><strong><u>事件传播的最上层对象是<code>window</code>，接着依次是<code>document</code>，<code>html</code>（<code>document.documentElement</code>）和<code>body</code>（<code>document.body</code>）。也就是说，上例的事件传播顺序，在捕获阶段依次为<code>window</code>、<code>document</code>、<code>html</code>、<code>body</code>、<code>div</code>、<code>p</code>，在冒泡阶段依次为<code>p</code>、<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>window</code>。</u></strong></p>
<h1 id="事件的代理：父节点的监听函数统一处理多个子元素的事件"><a href="#事件的代理：父节点的监听函数统一处理多个子元素的事件" class="headerlink" title="事件的代理：父节点的监听函数统一处理多个子元素的事件"></a>事件的代理：父节点的监听函数统一处理多个子元素的事件</h1><p><strong>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line"></span><br><span class="line">ul.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.tagName.toLowerCase() === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码中，<code>click</code>事件的监听函数定义在<code>&lt;ul&gt;</code>节点，但是实际上，它处理的是子节点<code>&lt;li&gt;</code>的<code>click</code>事件。这样做的好处是，只要定义一个监听函数，就能处理多个子节点的事件，而不用在每个<code>&lt;li&gt;</code>节点上定义监听函数。而且以后再添加子节点，监听函数依然有效。</strong></p>
<h2 id="阻止事件传播：stopPropagation方法"><a href="#阻止事件传播：stopPropagation方法" class="headerlink" title="阻止事件传播：stopPropagation方法"></a>阻止事件传播：<code>stopPropagation</code>方法</h2><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播了</span></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡了</span></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>stopPropagation</code>方法只会阻止事件的传播，<strong>不会阻止该事件触发<code>&lt;p&gt;</code>节点的其他<code>click</code>事件的监听函数。也就是说，不是彻底取消<code>click</code>事件。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 会触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码中，<code>p</code>元素绑定了两个<code>click</code>事件的监听函数。<code>stopPropagation</code>方法只能阻止这个事件向其他元素传播。因此，第二个监听函数会触发。输出结果会先是1，然后是2。</strong></p>
<h2 id="立即阻止事件传播：stopImmediatePropagation方法"><a href="#立即阻止事件传播：stopImmediatePropagation方法" class="headerlink" title="立即阻止事件传播：stopImmediatePropagation方法"></a>立即阻止事件传播：<code>stopImmediatePropagation</code>方法</h2><p><strong>如果想要彻底阻止这个事件的传播，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不会被触发</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>stopImmediatePropagation</code>方法可以彻底阻止这个事件传播，使得后面绑定的所有<code>click</code>监听函数都不再触发。所以，只会输出1，不会输出2。</p>
<h1 id="Event对象概述"><a href="#Event对象概述" class="headerlink" title="Event对象概述"></a>Event对象概述</h1><p><strong>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</strong></p>
<h4 id="Event对象本身就是一个构造函数，可以用来生成新的实例。"><a href="#Event对象本身就是一个构造函数，可以用来生成新的实例。" class="headerlink" title="Event对象本身就是一个构造函数，可以用来生成新的实例。"></a><code>Event</code>对象本身就是一个构造函数，可以用来生成新的实例。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event = <span class="keyword">new</span> Event(type, options);</span><br></pre></td></tr></table></figure>
<p><strong>第一个参数<code>type</code>是字符串，表示事件的名称</strong>；<strong>第二个参数<code>options</code>是一个对象，表示事件对象的配置</strong>。该对象主要有下面两个属性。</p>
<ul>
<li><code>bubbles</code>：<strong>布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</strong></li>
<li><code>cancelable</code>：<strong>布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，<u>即能否用<code>Event.preventDefault()</code>取消这个事件。</u>一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event(</span><br><span class="line">  <span class="string">'look'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'bubbles'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'cancelable'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>look</code>事件实例，然后使用<code>dispatchEvent</code>方法触发该事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tag = event.currentTarget.tagName;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Tag: '</span> + tag); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, callback, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> click = <span class="keyword">new</span> Event(<span class="string">'click'</span>);</span><br><span class="line">p.dispatchEvent(click);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素发出一个<code>click</code>事件，该事件默认不会冒泡。<code>div.addEventListener</code>方法指定在冒泡阶段监听，因此监听函数不会触发。如果写成<code>div.addEventListener(&#39;click&#39;, callback, true)</code>，那么在“捕获阶段”可以监听到这个事件。<strong>事件定义时第二个参数的默认为“捕获阶段触发”，使用addEventListener方法绑定事件时默认为‘冒泡阶段触发。’</strong></p>
<p>另一方面，如果这个事件在<code>div</code>元素上触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.dispatchEvent(click);</span><br></pre></td></tr></table></figure>
<p><strong>那么，不管<code>div</code>元素是在冒泡阶段监听，还是在捕获阶段监听，都会触发监听函数。因为这时<code>div</code>元素是事件的目标，不存在是否冒泡的问题，<code>div</code>元素总是会接收到事件，因此导致监听函数生效。</strong></p>
<h1 id="Event对象的实例属性"><a href="#Event对象的实例属性" class="headerlink" title="Event对象的实例属性"></a>Event对象的实例属性</h1><h2 id="Event-bubbles属性返回一个布尔值，表示当前事件是否会冒泡。"><a href="#Event-bubbles属性返回一个布尔值，表示当前事件是否会冒泡。" class="headerlink" title="Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。"></a>Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。</h2><p><strong>该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<u><code>Event</code>构造函数生成的事件，默认是不冒泡的。</u></strong></p>
<h2 id="Event-eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。"><a href="#Event-eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。" class="headerlink" title="Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。"></a>Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> phase = event.eventPhase;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>0，事件目前没有发生。</strong></li>
<li><strong>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</strong></li>
<li><strong>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</strong></li>
<li><strong>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</strong></li>
</ul>
<h2 id="Event-cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性"><a href="#Event-cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性" class="headerlink" title="Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性"></a>Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性</h2><p>大多数浏览器的原生事件是可以取消的。比如，取消<code>click</code>事件，点击链接将无效。<strong>但是除非显式声明，<code>Event</code>构造函数生成的事件，默认是不可以取消的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">'foo'</span>);</span><br><span class="line">evt.cancelable  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>当<code>Event.cancelable</code>属性为<code>true</code>时，调用<code>Event.preventDefault()</code>就可以取消这个事件，阻止浏览器对该事件的默认行为。</p>
<p>如果事件不能取消，调用<code>Event.preventDefault()</code>会没有任何效果。所以使用这个方法之前，最好用<code>Event.cancelable</code>属性判断一下是否可以取消。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.cancelable) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'This event couldn\'t be canceled.'</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(event);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Event-cancelBubble属性是一个布尔值，如果设为true，相当于执行Event-stopPropagation-，可以阻止事件的传播。"><a href="#Event-cancelBubble属性是一个布尔值，如果设为true，相当于执行Event-stopPropagation-，可以阻止事件的传播。" class="headerlink" title="Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。"></a>Event.cancelBubble属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</h2><h2 id="Event-defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event-preventDefault方法。该属性只读。"><a href="#Event-defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event-preventDefault方法。该属性只读。" class="headerlink" title="Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。"></a>Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.defaultPrevented) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该事件已经取消了'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Event-currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。"><a href="#Event-currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。" class="headerlink" title="Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。"></a>Event.currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</h2><h2 id="Event-Target属性返回原始触发事件的那个节点，即事件最初发生的节点。"><a href="#Event-Target属性返回原始触发事件的那个节点，即事件最初发生的节点。" class="headerlink" title="Event.Target属性返回原始触发事件的那个节点，即事件最初发生的节点。"></a>Event.Target属性返回原始触发事件的那个节点，即事件最初发生的节点。</h2><p>不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;p id="para"&gt;Hello &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hide</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget);  <span class="comment">// 总是 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);  <span class="comment">// 有可能不是 true</span></span><br><span class="line">  e.target.style.visibility = <span class="string">'hidden'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">para.addEventListener(<span class="string">'click'</span>, hide, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果在<code>para</code>节点的<code>&lt;em&gt;</code>子节点上面点击，则<code>e.target</code>指向<code>&lt;em&gt;</code>子节点，导致<code>&lt;em&gt;</code>子节点（即 World 部分）会不可见。如果点击 Hello 部分，则整个<code>para</code>都将不可见。</p>
<h2 id="Event-type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。"><a href="#Event-type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。" class="headerlink" title="Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。"></a>Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候。该属性只读。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evt = <span class="keyword">new</span> Event(<span class="string">'foo'</span>);</span><br><span class="line">evt.type <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<h2 id="Event-detail属性只有浏览器的-UI-（用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。"><a href="#Event-detail属性只有浏览器的-UI-（用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。" class="headerlink" title="Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。"></a>Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。</h2><p>具体含义与事件类型相关。比如，对于<code>click</code>和<code>dbclick</code>事件，<code>Event.detail</code>是鼠标按下的次数（<code>1</code>表示单击，<code>2</code>表示双击，<code>3</code>表示三击）；对于鼠标滚轮事件，<code>Event.detail</code>是滚轮正向滚动的距离，负值就是负向滚动的距离，返回值总是3的倍数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveDetails</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'p'</span>).onclick = giveDetails;</span><br></pre></td></tr></table></figure>
<h1 id="Event对象的实例方法"><a href="#Event对象的实例方法" class="headerlink" title="Event对象的实例方法"></a>Event对象的实例方法</h1><h2 id="Event-preventDefault-取消浏览器对当前事件的默认行为"><a href="#Event-preventDefault-取消浏览器对当前事件的默认行为" class="headerlink" title="Event.preventDefault()取消浏览器对当前事件的默认行为"></a>Event.preventDefault()取消浏览器对当前事件的默认行为</h2><p><strong>该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</strong></p>
<p><strong><u>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法</u>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type="checkbox" id="my-checkbox" /&gt;</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="built_in">document</span>.getElementById(<span class="string">'my-checkbox'</span>);</span><br><span class="line"></span><br><span class="line">cb.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>)</span>&#123; e.preventDefault(); &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，浏览器的默认行为是单击会选中单选框，取消这个行为，就导致无法选中单选框。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;input type="text" id="my-input" /&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'my-input'</span>);</span><br><span class="line">input.addEventListener(<span class="string">'keypress'</span>, checkName, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.charCode &lt; <span class="number">97</span> || e.charCode &gt; <span class="number">122</span>) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码为文本框的<code>keypress</code>事件设定监听函数后，将只能输入小写字母，否则输入事件的默认行为（写入文本框）将被取消，导致不能向文本框输入内容。</p>
<h2 id="Event-stopPropagation-方法阻止事件在-DOM-中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。"><a href="#Event-stopPropagation-方法阻止事件在-DOM-中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。" class="headerlink" title="Event.stopPropagation()方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。"></a>Event.stopPropagation()方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, stopEvent, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件将不会进一步冒泡到<code>el</code>节点的父节点。</p>
<h2 id="Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点"><a href="#Event-stopImmediatePropagation-阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点" class="headerlink" title="Event.stopImmediatePropagation()阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点."></a>Event.stopImmediatePropagation()阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点.</h2><p>也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p>
<p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l1</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopImmediatePropagation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">l2</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, l1, <span class="literal">false</span>);</span><br><span class="line">el.addEventListener(<span class="string">'click'</span>, l2, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码在<code>el</code>节点上，为<code>click</code>事件添加了两个监听函数<code>l1</code>和<code>l2</code>。由于<code>l1</code>调用了<code>event.stopImmediatePropagation</code>方法，所以<code>l2</code>不会被调用。</p>
<h2 id="Event-composedPath-返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。"><a href="#Event-composedPath-返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。" class="headerlink" title="Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。"></a>Event.composedPath()返回一个数组，成员是事件的最底层节点和<u>依次冒泡经过的</u>所有上层节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div&gt;</span></span><br><span class="line"><span class="comment">//   &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line">div.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.composedPath());</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// [p, div, body, html, document, Window]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件的最底层节点是<code>p</code>，向上依次是<code>div</code>、<code>body</code>、<code>html</code>、<code>document</code>、<code>Window</code>。</p>
<h1 id="CustomEvent接口：用于生成自定义的事件实例"><a href="#CustomEvent接口：用于生成自定义的事件实例" class="headerlink" title="CustomEvent接口：用于生成自定义的事件实例"></a>CustomEvent接口：用于生成自定义的事件实例</h1><p>那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<h4 id="浏览器原生提供CustomEvent-构造函数，用来生成-CustomEvent-事件实例。"><a href="#浏览器原生提供CustomEvent-构造函数，用来生成-CustomEvent-事件实例。" class="headerlink" title="浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。"></a>浏览器原生提供CustomEvent()构造函数，用来生成 CustomEvent 事件实例。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure>
<p>第一个参数是字符串，表示事件的名字，这是必须的。第二个参数是事件的配置对象，这个参数是可选的。<code>CustomEvent</code>的配置对象除了接受 Event 事件的配置属性，只有一个自己的属性。</p>
<ul>
<li><strong><code>detail</code>：表示事件的附带数据，默认为<code>null</code></strong>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="string">'detail'</span>: <span class="string">'hello'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.detail);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们手动定义了<code>build</code>事件。该事件触发后，会被监听到，从而输出该事件实例的<code>detail</code>属性（即字符串<code>hello</code>）。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'myevent'</span>, &#123;</span><br><span class="line">  detail: &#123;</span><br><span class="line">    foo: <span class="string">'bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bubbles: <span class="literal">true</span>,</span><br><span class="line">  cancelable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">'myevent'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + event.detail.foo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>
<p>上面代码也说明，CustomEvent 的事件实例，除了具有 Event 接口的实例属性，还具有<code>detail</code>属性。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-10T09:09:08.022Z" itemprop="dateUpdated">2019-08-10 17:09:08</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/08/09/JS学习之事件模型/" target="_blank" rel="external">http://hedroins.github.io/2019/08/09/JS学习之事件模型/</a>
        
    </div>
    
    <footer>
        <a href="http://hedroins.github.io">
            <img src="/img/avatar.jpg" alt="HeJL">
            HeJL
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事件模型/">事件模型</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&title=《JS学习之事件模型》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&title=《JS学习之事件模型》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/08/09/JS学习之事件模型/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之事件模型》 — HeJL&url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/11/JS学习之事件类型1/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JS学习之事件类型</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/08/08/JS学习之Text节点和DocumentFragment节点/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JS学习之Text节点和DocumentFragment节点</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>HeJL &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&title=《JS学习之事件模型》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&title=《JS学习之事件模型》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/08/09/JS学习之事件模型/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之事件模型》 — HeJL&url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/08/09/JS学习之事件模型/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://hedroins.github.io/2019/08/09/JS学习之事件模型/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
