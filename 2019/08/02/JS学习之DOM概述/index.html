<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=true"></script>
<!-- End Tencent Analysis -->


    



    <meta charset="utf-8">
    
    
    
    
    <title>JS学习之DOM概述 | HeJL | just,Try!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="DOM概述">
    <meta name="description" content="基本概念DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点有七种类型： D">
<meta name="keywords" content="DOM概述">
<meta property="og:type" content="article">
<meta property="og:title" content="JS学习之DOM概述">
<meta property="og:url" content="http://hedroins.github.io/2019/08/02/JS学习之DOM概述/index.html">
<meta property="og:site_name" content="HeJL">
<meta property="og:description" content="基本概念DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点有七种类型： D">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-04T05:29:49.835Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS学习之DOM概述">
<meta name="twitter:description" content="基本概念DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。 节点DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点有七种类型： D">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">HeJL</h5>
          <a href="mailto:1047867332@qq.com" title="1047867332@qq.com" class="mail">1047867332@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/Hedroins" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/dream"  >
                <i class="icon icon-lg icon-dream"></i>
                Dream
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">JS学习之DOM概述</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">JS学习之DOM概述</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-01T17:06:23.000Z" itemprop="datePublished" class="page-time">
  2019-08-02
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#基本概念"><span class="post-toc-number">1.</span> <span class="post-toc-text">基本概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#DOM"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">DOM</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#节点"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">节点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#节点树"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">节点树</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Mode接口属性"><span class="post-toc-number">2.</span> <span class="post-toc-text">Mode接口属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-nodeType属性：返回一个整数值，表示节点的类型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">Node.nodeType属性：返回一个整数值，表示节点的类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-nodeName-返回节点的名称"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Node.nodeName:返回节点的名称</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-nodeValue-表示当前节点本身的文本值，该属性可读写"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Node.nodeValue:表示当前节点本身的文本值，该属性可读写</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-textContent：属性返回当前节点和它的所有后代节点的文本内容。"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">Node.textContent：属性返回当前节点和它的所有后代节点的文本内容。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-baseURI-返回一个字符串，表示当前网页的绝对路径。"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">Node.baseURI:返回一个字符串，表示当前网页的绝对路径。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-ownerDocument-返回当前节点所在的顶层文档对象，即document对象"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">Node.ownerDocument:返回当前节点所在的顶层文档对象，即document对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-nextSibling-返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">Node.nextSibling:返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#nextSibling属性可以用来遍历所有子节点。"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">nextSibling属性可以用来遍历所有子节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null"><span class="post-toc-number">2.9.</span> <span class="post-toc-text">Node.previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-parentNode属性返回当前节点的父节点。"><span class="post-toc-number">2.10.</span> <span class="post-toc-text">Node.parentNode属性返回当前节点的父节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。"><span class="post-toc-number">2.11.</span> <span class="post-toc-text">Node.parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-firstChild-Node-lastChild"><span class="post-toc-number">2.12.</span> <span class="post-toc-text">Node.firstChild,Node.lastChild</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-childNodes属性返回一个类似数组的对象-NodeList集合-，成员包括当前节点的所有子节点。"><span class="post-toc-number">2.13.</span> <span class="post-toc-text">Node.childNodes属性返回一个类似数组的对象(NodeList集合)，成员包括当前节点的所有子节点。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文档类型-document-就有两个子节点：文档类型节点-doctype-和HTML根元素节点。"><span class="post-toc-number">2.13.1.</span> <span class="post-toc-text">文档类型(document)就有两个子节点：文档类型节点(doctype)和HTML根元素节点。</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-isConnected属性返回一个布尔值，表示当前节点是否在文档之中。"><span class="post-toc-number">2.14.</span> <span class="post-toc-text">Node.isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Node接口的方法"><span class="post-toc-number">3.</span> <span class="post-toc-text">Node接口的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-appendChild-方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Node.appendChild()方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-hasChildNodes-方法返回一个布尔值，表示当前节点是否有子节点"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Node.hasChildNodes()方法返回一个布尔值，表示当前节点是否有子节点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-cloneNode-方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Node.cloneNode()方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#该方法的一些使用注意点："><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">该方法的一些使用注意点：</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-insertBefore-方法用于将某个节点插入父节点内部的指定位置。"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">Node.insertBefore()方法用于将某个节点插入父节点内部的指定位置。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-removeChild-方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">Node.removeChild()方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-replaceChild-用于将一个新的节点，替换当前节点的某一个子节点。"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">Node.replaceChild()用于将一个新的节点，替换当前节点的某一个子节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-contains-返回一个布尔值，表示参数节点是否满足以下三个条件之一"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">Node.contains()返回一个布尔值，表示参数节点是否满足以下三个条件之一.</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-compareDocumentPosition-方法的用法，与contains-方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">Node.compareDocumentPosition()方法的用法，与contains 方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-isEqualNode-Node-isSameNode"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">Node.isEqualNode(),Node.isSameNode()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-normalize-方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。"><span class="post-toc-number">3.10.</span> <span class="post-toc-text">Node.normalize()方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Node-getRootNode-方法返回当前节点所在文档的根节点"><span class="post-toc-number">3.11.</span> <span class="post-toc-text">Node.getRootNode()方法返回当前节点所在文档的根节点</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#NodeList接口"><span class="post-toc-number">4.</span> <span class="post-toc-text">NodeList接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#概述"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NodeList-prototype-length属性返回-NodeList-实例包含的节点数量。"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">NodeList.prototype.length属性返回 NodeList 实例包含的节点数量。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NodeList-prototype-forEach-用于遍历-NodeList-的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">NodeList.prototype.forEach()用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NodeList-prototype-item-接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">NodeList.prototype.item()接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#HTMLCollection接口"><span class="post-toc-number">5.</span> <span class="post-toc-text">HTMLCollection接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#概述-1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTMLConllection-prototype-length属性返回HTMLCollection实例包含的成员数量。"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">HTMLConllection.prototype.length属性返回HTMLCollection实例包含的成员数量。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTMLConllection-prototype-item-方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">HTMLConllection.prototype.item()方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTMLConllection-prototype-namedItem-方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">HTMLConllection.prototype.namedItem()方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ParentNode接口"><span class="post-toc-number">6.</span> <span class="post-toc-text">ParentNode接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ParentNode-children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">ParentNode.children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ParentNode-firstElementChild-属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">ParentNode.firstElementChild()属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ParentNode-childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">ParentNode.childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ParentNode-append-ParentNode-prepend"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">ParentNode.append(),ParentNode.prepend()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。"><span class="post-toc-number">6.4.0.1.</span> <span class="post-toc-text">append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#ChildNode接口"><span class="post-toc-number">7.</span> <span class="post-toc-text">ChildNode接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ChildNode-remove"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">ChildNode.remove()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ChildNode-before-ChildNode-after"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">ChildNode.before(),ChildNode.after()</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ChildNode-replaceWith"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">ChildNode.replaceWith()</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-JS学习之DOM概述"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">JS学习之DOM概述</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-02 01:06:23" datetime="2019-08-01T17:06:23.000Z"  itemprop="datePublished">2019-08-02</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。</p>
<p>节点有七种类型：</p>
<p><strong>Document:整个文档树的顶层节点。</strong></p>
<p><strong>DocumentType:doctype标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</strong></p>
<p><strong>Element:网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</strong></p>
<p><strong>Attribute:网页元素的属性（比如class=”right”）</strong></p>
<p><strong>Text:标签之间或标签包含的文本</strong></p>
<p><strong>DocumentFragment:文档的片段</strong></p>
<p>浏览器提供一个原生的节点对象<code>Node</code>，上面这七种节点都继承了<code>Node</code>，因此具有一些共同的属性和方法。</p>
<h2 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h2><p>一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，倒过来就像一棵树。</p>
<p>浏览器原生提供<code>document</code>节点，代表整个文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span></span><br><span class="line"><span class="comment">// 整个文档树</span></span><br></pre></td></tr></table></figure>
<p>文档的第一层只有一个节点，就是 HTML 网页的第一个标签<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他 HTML 标签节点都是它的下级节点。</p>
<p>除了根节点，其他节点都有三种层级关系。</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<p>DOM 提供操作接口，用来获取这三种关系的节点。比如，子节点接口包括<code>firstChild</code>（第一个子节点）和<code>lastChild</code>（最后一个子节点）等属性，同级节点接口包括<code>nextSibling</code>（紧邻在后的那个同级节点）和<code>previousSibling</code>（紧邻在前的那个同级节点）属性。</p>
<h1 id="Mode接口属性"><a href="#Mode接口属性" class="headerlink" title="Mode接口属性"></a>Mode接口属性</h1><p>所有 DOM 节点都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>
<h2 id="Node-nodeType属性：返回一个整数值，表示节点的类型"><a href="#Node-nodeType属性：返回一个整数值，表示节点的类型" class="headerlink" title="Node.nodeType属性：返回一个整数值，表示节点的类型"></a>Node.nodeType属性：返回一个整数值，表示节点的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的类型值为9。</p>
<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>不同节点的nodeType属性和对应的常量如下。</p>
<ul>
<li>文档节点（document）：9，对应常量<code>Node.DOCUMENT_NODE</code></li>
<li>元素节点（element）：1，对应常量<code>Node.ELEMENT_NODE</code></li>
<li>属性节点（attr）：2，对应常量<code>Node.ATTRIBUTE_NODE</code></li>
<li>文本节点（text）：3，对应常量<code>Node.TEXT_NODE</code></li>
<li>文档片断节点（DocumentFragment）：11，对应常量<code>Node.DOCUMENT_FRAGMENT_NODE</code></li>
<li>文档类型节点（DocumentType）：10，对应常量<code>Node.DOCUMENT_TYPE_NODE</code></li>
<li>注释节点（Comment）：8，对应常量<code>Node.COMMENT_NODE</code></li>
</ul>
<p>确定节点类型时，使用<code>nodeType</code>属性是常用方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.documentElement.firstChild;</span><br><span class="line"><span class="keyword">if</span> (node.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该节点是元素节点'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Node-nodeName-返回节点的名称"><a href="#Node-nodeName-返回节点的名称" class="headerlink" title="Node.nodeName:返回节点的名称"></a>Node.nodeName:返回节点的名称</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line">div.nodeName <span class="comment">// "DIV"</span></span><br></pre></td></tr></table></figure>
<p>不同节点的nodeName属性值如下：</p>
<p>​     </p>
<ul>
<li>文档节点（document）：<code>#document</code></li>
<li>元素节点（element）：大写的标签名</li>
<li>属性节点（attr）：属性的名称</li>
<li>文本节点（text）：<code>#text</code></li>
<li>文档片断节点（DocumentFragment）：<code>#document-fragment</code></li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：<code>#comment</code></li>
</ul>
<h2 id="Node-nodeValue-表示当前节点本身的文本值，该属性可读写"><a href="#Node-nodeValue-表示当前节点本身的文本值，该属性可读写" class="headerlink" title="Node.nodeValue:表示当前节点本身的文本值，该属性可读写"></a>Node.nodeValue:表示当前节点本身的文本值，该属性可读写</h2><p><strong>只有文本节点（text）和注释节点（comment）有文本值，因此这两类节点的<code>nodeValue</code>可以返回结果，其他类型的节点一律返回<code>null</code></strong>。同样的，<strong>也只有这两类节点可以设置<code>nodeValue</code>属性的值，其他类型的节点设置无效</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line">div.nodeValue <span class="comment">// null</span></span><br><span class="line">div.firstChild.nodeValue <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>
<p>上面代码，<strong>div是元素节点，nodeValue属性返回null。div.firstChild是文本节点，所以可以返回文本值。</strong></p>
<h2 id="Node-textContent：属性返回当前节点和它的所有后代节点的文本内容。"><a href="#Node-textContent：属性返回当前节点和它的所有后代节点的文本内容。" class="headerlink" title="Node.textContent：属性返回当前节点和它的所有后代节点的文本内容。"></a>Node.textContent：属性返回当前节点和它的所有后代节点的文本内容。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'divA'</span>).textContent</span><br><span class="line"><span class="comment">// This is some text</span></span><br></pre></td></tr></table></figure>
<p>textContent属性自动忽略当前节点内部的HTML标签，返回所有文本内容。</p>
<p><strong>该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。</strong><u>它还有一个好处，就是自动对 HTML 标签转义。这很适合用于用户提供的内容。</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).textContent = <span class="string">'&lt;p&gt;GoodBye!&lt;/p&gt;'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码在插入文本时，会将</p><p>标签解释为文本，而不会当作标签处理。</p>
<p><strong>对于文本节点(text)和注释节点(comment),textContent属性的值与nodeValue属性相同。</strong> <strong>对于其他类型的节点，该属性会将每个子节点的内容连在一起返回，但是不包括注释节点。如果一个节点没有子节点，则返回空字符串。</strong></p>
<p><strong>文档节点(document)和文档类型节点(doctype)的textContent属性为null。如果要读取整个文档的内容，可以使用<code>document.documentElement.textContent</code>。</strong></p>
<h2 id="Node-baseURI-返回一个字符串，表示当前网页的绝对路径。"><a href="#Node-baseURI-返回一个字符串，表示当前网页的绝对路径。" class="headerlink" title="Node.baseURI:返回一个字符串，表示当前网页的绝对路径。"></a>Node.baseURI:返回一个字符串，表示当前网页的绝对路径。</h2><p>浏览器根据这个属性，计算网页上的相对路径的URI。该属性为只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前网页的网址为</span></span><br><span class="line"><span class="comment">// http://www.example.com/index.html</span></span><br><span class="line"><span class="built_in">document</span>.baseURI</span><br><span class="line"><span class="comment">// "http://www.example.com/index.html"</span></span><br></pre></td></tr></table></figure>
<p><strong>如果无法读到网页的URL,baseURI属性返回null。</strong></p>
<p>该属性的值一般由当前网址的URL(即window.location属性)决定，但是可以使用HTML的\<base>标签，改变该属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=<span class="string">"http://www.example.com/page.html"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>设置了以后，baseURI属性就返回\<base>标签设置的值。</p>
<h2 id="Node-ownerDocument-返回当前节点所在的顶层文档对象，即document对象"><a href="#Node-ownerDocument-返回当前节点所在的顶层文档对象，即document对象" class="headerlink" title="Node.ownerDocument:返回当前节点所在的顶层文档对象，即document对象"></a>Node.ownerDocument:返回当前节点所在的顶层文档对象，即document对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = p.ownerDocument;</span><br><span class="line">d === <span class="built_in">document</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>document</code>对象本身的<code>ownerDocument</code>属性，返回<code>null</code>。</p>
<h2 id="Node-nextSibling-返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。"><a href="#Node-nextSibling-返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。" class="headerlink" title="Node.nextSibling:返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。"></a>Node.nextSibling:返回紧跟着当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">'d2'</span>);</span><br><span class="line"></span><br><span class="line">d1.nextSibling === d2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>上面的代码中，<code>d1.nextSibling</code>就是紧跟在d1后面的同级节点d2。</strong></p>
<p>注意，该属性还包括文本节点和注释节点(\<!-- comment -->) 。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h2 id="nextSibling属性可以用来遍历所有子节点。"><a href="#nextSibling属性可以用来遍历所有子节点。" class="headerlink" title="nextSibling属性可以用来遍历所有子节点。"></a><code>nextSibling</code>属性可以用来遍历所有子节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).firstChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (el !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el.nodeName);</span><br><span class="line">  el = el.nextSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码遍历div1节点的所有子节点。</p>
<h2 id="Node-previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null"><a href="#Node-previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null" class="headerlink" title="Node.previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null"></a>Node.previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> div2 = <span class="built_in">document</span>.getElementById(<span class="string">'d2'</span>);</span><br><span class="line"></span><br><span class="line">d2.previousSibling === d1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>d2.previousSibling</code>就是<code>d2</code>前面的同级节点<code>d1</code>。</p>
<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点前面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h2 id="Node-parentNode属性返回当前节点的父节点。"><a href="#Node-parentNode属性返回当前节点的父节点。" class="headerlink" title="Node.parentNode属性返回当前节点的父节点。"></a>Node.parentNode属性返回当前节点的父节点。</h2><p><strong>对于一个节点来说，它的父节点只可能是三种类型：元素节点(element)、文档节点(document)和文档片段节点(documentfragment)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，通过<code>node.parentNode</code>属性将<code>node</code>节点从文档里面删除。</p>
<p><strong>文档节点(document)和文档片段节点(documentfragment)的父节点都是<code>null</code>。另外，对于那些生成后还没插入DOM树的节点，父节点也是    <code>null</code>。</strong></p>
<h2 id="Node-parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。"><a href="#Node-parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。" class="headerlink" title="Node.parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。"></a>Node.parentElement属性返回节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，父元素节点的样式设定了红色。</p>
<h2 id="Node-firstChild-Node-lastChild"><a href="#Node-firstChild-Node-lastChild" class="headerlink" title="Node.firstChild,Node.lastChild"></a>Node.firstChild,Node.lastChild</h2><p><code>firstChild</code>属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。、</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id="p1"&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// "SPAN"</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>firstChild</code>返回的除了元素节点，还可能是文本节点或注释节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id="p1"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;span&gt;First span&lt;/span&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// "#text"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>元素与<code>span</code>元素之间有空白字符，这导致<code>firstChild</code>返回的是文本节点。</p>
<p><strong><code>lastChild</code>属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回<code>null</code>。用法与<code>firstChild</code>属性相同。</strong></p>
<h2 id="Node-childNodes属性返回一个类似数组的对象-NodeList集合-，成员包括当前节点的所有子节点。"><a href="#Node-childNodes属性返回一个类似数组的对象-NodeList集合-，成员包括当前节点的所有子节点。" class="headerlink" title="Node.childNodes属性返回一个类似数组的对象(NodeList集合)，成员包括当前节点的所有子节点。"></a>Node.childNodes属性返回一个类似数组的对象(NodeList集合)，成员包括当前节点的所有子节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).childNodes;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>children</code>就是<code>ul</code>元素的所有子节点。</p>
<p>使用该属性，可以遍历某个节点的所有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"><span class="keyword">var</span> children = div.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文档类型-document-就有两个子节点：文档类型节点-doctype-和HTML根元素节点。"><a href="#文档类型-document-就有两个子节点：文档类型节点-doctype-和HTML根元素节点。" class="headerlink" title="文档类型(document)就有两个子节点：文档类型节点(doctype)和HTML根元素节点。"></a>文档类型(document)就有两个子节点：文档类型节点(doctype)和HTML根元素节点。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.childNodes;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(children[i].nodeType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档节点的第一个子节点的类型是10（即文档类型节点），第二个子节点的类型是1（即元素节点）。</p>
<p><strong>注意，除了元素节点，<code>childNodes</code>属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的<code>NodeList</code>集合。由于<code>NodeList</code>对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。</strong></p>
<h2 id="Node-isConnected属性返回一个布尔值，表示当前节点是否在文档之中。"><a href="#Node-isConnected属性返回一个布尔值，表示当前节点是否在文档之中。" class="headerlink" title="Node.isConnected属性返回一个布尔值，表示当前节点是否在文档之中。"></a>Node.isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">test.isConnected <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(test);</span><br><span class="line">test.isConnected <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>test</code>节点是脚本生成的节点，没有插入文档之前，<code>isConnected</code>属性返回<code>false</code>，插入之后返回<code>true</code>。</p>
<h1 id="Node接口的方法"><a href="#Node接口的方法" class="headerlink" title="Node接口的方法"></a>Node接口的方法</h1><h2 id="Node-appendChild-方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。"><a href="#Node-appendChild-方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。" class="headerlink" title="Node.appendChild()方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。"></a>Node.appendChild()方法接收一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span><br></pre></td></tr></table></figure>
<p>上面代码新建一个<code>&lt;p&gt;</code>节点，将其插入<code>document.body</code>的尾部。</p>
<p>如果参数节点是 DOM 已经存在的节点，<code>appendChild</code>方法会将其从原来的位置，移动到新位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span></span><br><span class="line">  .createElement(<span class="string">'div'</span>)</span><br><span class="line">  .appendChild(<span class="built_in">document</span>.createElement(<span class="string">'b'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码的返回值是<code>&lt;b&gt;&lt;/b&gt;</code>，而不是<code>&lt;div&gt;&lt;/div&gt;</code>。</p>
<p><strong>如果<code>appendChild</code>方法的参数是<code>DocumentFragment</code>节点，那么插入的是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值是一个空的<code>DocumentFragment</code>节点。</strong></p>
<h2 id="Node-hasChildNodes-方法返回一个布尔值，表示当前节点是否有子节点"><a href="#Node-hasChildNodes-方法返回一个布尔值，表示当前节点是否有子节点" class="headerlink" title="Node.hasChildNodes()方法返回一个布尔值，表示当前节点是否有子节点"></a>Node.hasChildNodes()方法返回一个布尔值，表示当前节点是否有子节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo.hasChildNodes()) &#123;</span><br><span class="line">  foo.removeChild(foo.childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果<code>foo</code>节点有子节点，就移除第一个子节点。</p>
<p>注意，子节点包括所有节点，哪怕节点只包含一个空格，<code>hasChildNodes</code>方法也会返回<code>true</code>。</p>
<p><strong>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</strong></p>
<ul>
<li><strong><code>node.hasChildNodes()</code></strong></li>
<li><strong><code>node.firstChild !== null</code></strong></li>
<li><strong><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></strong></li>
</ul>
<p><strong><code>hasChildNodes</code>方法结合<code>firstChild</code>属性和<code>nextSibling</code>属性，可以遍历当前节点的所有后代节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOMComb</span>(<span class="params">parent, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent.hasChildNodes()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> node = parent.firstChild; node; node = node.nextSibling) &#123;</span><br><span class="line">      DOMComb(node, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callback(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">DOMComb(<span class="built_in">document</span>.body, <span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>DOMComb</code>函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。</p>
<h2 id="Node-cloneNode-方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。"><a href="#Node-cloneNode-方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。" class="headerlink" title="Node.cloneNode()方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。"></a>Node.cloneNode()方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneUL = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).cloneNode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="该方法的一些使用注意点："><a href="#该方法的一些使用注意点：" class="headerlink" title="该方法的一些使用注意点："></a>该方法的一些使用注意点：</h3><p>（1）克隆一个节点，会拷贝该节点的所有属性，<strong>但是会丧失<code>addEventListener</code>方法和<code>on-</code>属性（即<code>node.onclick = fn</code>），添加在这个节点上的事件回调函数。</strong></p>
<p>（2）该方法返回的节点不在文档之中，即没有任何父节点，<strong>必须使用诸如<code>Node.appendChild</code>这样的方法添加到文档之中。</strong></p>
<p>（3）<strong>克隆一个节点之后，DOM 有可能出现两个有相同<code>id</code>属性（即<code>id=&quot;xxx&quot;</code>）的网页元素，这时应该修改其中一个元素的<code>id</code>属性。如果原节点有<code>name</code>属性，可能也需要修改。</strong></p>
<h2 id="Node-insertBefore-方法用于将某个节点插入父节点内部的指定位置。"><a href="#Node-insertBefore-方法用于将某个节点插入父节点内部的指定位置。" class="headerlink" title="Node.insertBefore()方法用于将某个节点插入父节点内部的指定位置。"></a>Node.insertBefore()方法用于将某个节点插入父节点内部的指定位置。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.insertBefore(newNode, referenceNode);</span><br></pre></td></tr></table></figure>
<p><code>insertBefore</code>方法接受两个参数，<strong>第一个参数是所要插入的节点<code>newNode</code>，第二个参数是父节点<code>parentNode</code>内部的一个子节点<code>referenceNode</code>。<code>newNode</code>将插在<code>referenceNode</code>这个子节点的前面。返回值是插入的新节点<code>newNode</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>
<p><strong>如果<code>insertBefore</code>方法的第二个参数为<code>null</code>，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>p</code>将成为<code>document.body</code>的最后一个子节点。这也说明<code>insertBefore</code>的第二个参数不能省略。</p>
<p><strong>注意，如果所要插入的节点是当前 DOM 现有的节点，则该节点将从原有的位置移除，插入新的位置。</strong></p>
<p><u>由于不存在<code>insertAfter</code>方法，如果新节点要插在父节点的某个子节点后面，可以用<code>insertBefore</code>方法结合<code>nextSibling</code>属性模拟。</u></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.insertBefore(s1, s2.nextSibling);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong><code>parent</code>是父节点，<code>s1</code>是一个全新的节点，<code>s2</code>是可以将<code>s1</code>节点，插在<code>s2</code>节点的后面。如果<code>s2</code>是当前节点的最后一个子节点，则<code>s2.nextSibling</code>返回<code>null</code>，这时<code>s1</code>节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在<code>s2</code>的后面。</strong></p>
<p>如果要插入的节点是<code>DocumentFragment</code>类型，那么插入的将是<code>DocumentFragment</code>的所有子节点，而不是<code>DocumentFragment</code>节点本身。返回值将是一个空的<code>DocumentFragment</code>节点。</p>
<h2 id="Node-removeChild-方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。"><a href="#Node-removeChild-方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。" class="headerlink" title="Node.removeChild()方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。"></a>Node.removeChild()方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">'A'</span>);</span><br><span class="line">divA.parentNode.removeChild(divA);</span><br></pre></td></tr></table></figure>
<p>上面代码移除了divA节点。注意，这个方法是在divA的父节点调用的，不是在divA上调用的。</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'top'</span>);</span><br><span class="line"><span class="keyword">while</span> (element.firstChild) &#123;</span><br><span class="line">  element.removeChild(element.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被移除的节点依然存在于内存之中，但不再是 DOM 的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。</p>
<p><strong>如果参数节点不是当前节点的子节点，<code>removeChild</code>方法将报错。</strong></p>
<h2 id="Node-replaceChild-用于将一个新的节点，替换当前节点的某一个子节点。"><a href="#Node-replaceChild-用于将一个新的节点，替换当前节点的某一个子节点。" class="headerlink" title="Node.replaceChild()用于将一个新的节点，替换当前节点的某一个子节点。"></a>Node.replaceChild()用于将一个新的节点，替换当前节点的某一个子节点。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>
<p><strong>上面代码中，<code>replaceChild</code>方法接受两个参数，第一个参数<code>newChild</code>是用来替换的新节点，第二个参数<code>oldChild</code>是将要替换走的子节点。返回值是替换走的那个节点<code>oldChild</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">'divA'</span>);</span><br><span class="line"><span class="keyword">var</span> newSpan = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">newSpan.textContent = <span class="string">'Hello World!'</span>;</span><br><span class="line">divA.parentNode.replaceChild(newSpan, divA);</span><br></pre></td></tr></table></figure>
<p>上面代码是如何将指定节点<code>divA</code>替换走。</p>
<h2 id="Node-contains-返回一个布尔值，表示参数节点是否满足以下三个条件之一"><a href="#Node-contains-返回一个布尔值，表示参数节点是否满足以下三个条件之一" class="headerlink" title="Node.contains()返回一个布尔值，表示参数节点是否满足以下三个条件之一."></a>Node.contains()返回一个布尔值，表示参数节点是否满足以下三个条件之一.</h2><ul>
<li>参数节点为当前节点。</li>
<li>参数节点为当前节点的子节点。</li>
<li>参数节点为当前节点的后代节点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contains(node)</span><br></pre></td></tr></table></figure>
<p>上面代码检查参数节点<code>node</code>，是否包含在当前文档之中。</p>
<p><strong>注意，当前节点传入<code>contains</code>方法，返回<code>true</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeA.contains(nodeA) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Node-compareDocumentPosition-方法的用法，与contains-方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。"><a href="#Node-compareDocumentPosition-方法的用法，与contains-方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。" class="headerlink" title="Node.compareDocumentPosition()方法的用法，与contains 方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。"></a>Node.compareDocumentPosition()方法的用法，与<code>contains</code> 方法完全一致，返回一个七个比特位的二进制值，表示参数节点与当前节点的关系。</h2><table>
<thead>
<tr>
<th>二进制值</th>
<th>十进制值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>000000</td>
<td>0</td>
<td>两个节点相同</td>
</tr>
<tr>
<td>000001</td>
<td>1</td>
<td>两个节点不在同一个文档（即有一个节点不在当前文档）</td>
</tr>
<tr>
<td>000010</td>
<td>2</td>
<td>参数节点在当前节点的前面</td>
</tr>
<tr>
<td>000100</td>
<td>4</td>
<td>参数节点在当前节点的后面</td>
</tr>
<tr>
<td>001000</td>
<td>8</td>
<td>参数节点包含当前节点</td>
</tr>
<tr>
<td>010000</td>
<td>16</td>
<td>当前节点包含参数节点</td>
</tr>
<tr>
<td>100000</td>
<td>32</td>
<td>浏览器内部使用</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="mydiv"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;form&gt;&lt;input id="test" /&gt;&lt;/form&gt;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">div.compareDocumentPosition(input) <span class="comment">// 20</span></span><br><span class="line">input.compareDocumentPosition(div) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p><strong>上面代码中，节点<code>div</code>包含节点<code>input</code>（二进制<code>010000</code>），而且节点<code>input</code>在节点<code>div</code>的后面（二进制<code>000100</code>），所以第一个<code>compareDocumentPosition</code>方法返回<code>20</code>（二进制<code>010100</code>，即<code>010000 + 000100</code>），第二个<code>compareDocumentPosition</code>方法返回<code>10</code>（二进制<code>001010</code>）。</strong></p>
<p>由于<code>compareDocumentPosition</code>返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.head;</span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">if</span> (head.compareDocumentPosition(body) &amp; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文档结构正确'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'&lt;body&gt; 不能在 &lt;head&gt; 前面'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Node-isEqualNode-Node-isSameNode"><a href="#Node-isEqualNode-Node-isSameNode" class="headerlink" title="Node.isEqualNode(),Node.isSameNode()"></a>Node.isEqualNode(),Node.isSameNode()</h2><p><code>isEqualNode</code>方法返回一个布尔值，<strong>用于检查两个节点是否相等。所</strong>谓相等的节点，指的是<strong>两个节点的类型相同、属性相同、子节点相同。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line">p1.isEqualNode(p2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong><code>isSameNode</code>方法返回一个布尔值，表示两个节点是否为同一个节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line">p1.isSameNode(p2) <span class="comment">// false</span></span><br><span class="line">p1.isSameNode(p1) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="Node-normalize-方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。"><a href="#Node-normalize-方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。" class="headerlink" title="Node.normalize()方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。"></a>Node.normalize()方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Part 1 '</span>));</span><br><span class="line">wrapper.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Part 2 '</span>));</span><br><span class="line"></span><br><span class="line">wrapper.childNodes.length <span class="comment">// 2</span></span><br><span class="line">wrapper.normalize();</span><br><span class="line">wrapper.childNodes.length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>上面代码使用<code>normalize</code>方法之前，<code>wrapper</code>节点有两个毗邻的文本子节点。使用<code>normalize</code>方法之后，两个文本子节点被合并成一个。</strong></p>
<p>该方法是<code>Text.splitText</code>的逆方法，可以查看《Text 节点对象》一章，了解更多内容。</p>
<h2 id="Node-getRootNode-方法返回当前节点所在文档的根节点"><a href="#Node-getRootNode-方法返回当前节点所在文档的根节点" class="headerlink" title="Node.getRootNode()方法返回当前节点所在文档的根节点"></a>Node.getRootNode()方法返回当前节点所在文档的根节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.firstChild.getRootNode() === <span class="built_in">document</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h1><p>节点都是单个对象，有时需要一种数据结构，能够容纳多个节点。<strong>DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code>和<code>HTMLCollection</code>。</strong></p>
<p>这两种集合都属于接口规范。许多 DOM 属性和方法，返回的结果是<code>NodeList</code>实例或<code>HTMLCollection</code>实例。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong><code>NodeList</code>实例是一个类似数组的对象，它的成员是节点对象。</strong>通过以下方法可以得到<code>NodeList</code>实例。</p>
<ul>
<li><code>Node.childNodes</code></li>
<li><code>document.querySelectorAll()</code>、<code>document.getElementsByTagName()</code>等节点搜索方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes <span class="keyword">instanceof</span> NodeList <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>NodeList</code>实例很像数组，可以使用<code>length</code>属性和<code>forEach</code>方法。但是，<strong>它不是数组，不能使用<code>pop</code>或<code>push</code>之类数组特有的方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(children) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">children.length <span class="comment">// 34</span></span><br><span class="line">children.forEach(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>
<p>上面代码中，NodeList 实例<code>children</code>不是数组，但是具有<code>length</code>属性和<code>forEach</code>方法。</p>
<p><strong>如果<code>NodeList</code>实例要使用数组方法，可以将其转为真正的数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"><span class="keyword">var</span> nodeArr = <span class="built_in">Array</span>.prototype.slice.call(children);</span><br></pre></td></tr></table></figure>
<p>除了使用<code>forEach</code>方法遍历 NodeList 实例，还可以使用<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> item = children[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，NodeList 实例可能是动态集合，也可能是静态集合。所谓动态集合就是一个活的集合，DOM 删除或新增一个相关节点，都会立刻反映在 NodeList 实例。目前，只有<code>Node.childNodes</code>返回的是一个动态集合，其他的 NodeList 都是静态集合。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line">children.length <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'p'</span>));</span><br><span class="line">children.length <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，文档增加一个子节点，NodeList 实例<code>children</code>的<code>length</code>属性就增加了1。</p>
<h2 id="NodeList-prototype-length属性返回-NodeList-实例包含的节点数量。"><a href="#NodeList-prototype-length属性返回-NodeList-实例包含的节点数量。" class="headerlink" title="NodeList.prototype.length属性返回 NodeList 实例包含的节点数量。"></a>NodeList.prototype.length属性返回 NodeList 实例包含的节点数量。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'xxx'</span>).length</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.getElementsByTagName</code>返回一个 NodeList 集合。<strong>对于那些不存在的 HTML 标签，<code>length</code>属性返回<code>0</code>。</strong></p>
<h2 id="NodeList-prototype-forEach-用于遍历-NodeList-的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。"><a href="#NodeList-prototype-forEach-用于遍历-NodeList-的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。" class="headerlink" title="NodeList.prototype.forEach()用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。"></a>NodeList.prototype.forEach()用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的<code>forEach</code>方法完全一致。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line">children.forEach(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">item, i, list</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<strong>回调函数<code>f</code>的三个参数依次是当前成员、位置和当前 NodeList 实例。 </strong><code>forEach</code>方法的第二个参数，用于绑定回调函数内部的<code>this</code>，该参数可省略。</p>
<h2 id="NodeList-prototype-item-接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"><a href="#NodeList-prototype-item-接受一个整数值作为参数，表示成员的位置，返回该位置上的成员" class="headerlink" title="NodeList.prototype.item()接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"></a>NodeList.prototype.item()接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes.item(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>item(0)</code>返回第一个成员。</p>
<p><strong>如果参数值大于实际长度，或者索引不合法（比如负数），<code>item</code>方法返回<code>null</code>。如果省略参数，<code>item</code>方法会报错。</strong></p>
<p>一般情况下，都是使用方括号运算符，而不使用<code>item</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries"><a href="#NodeList-prototype-keys-NodeList-prototype-values-NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()"></a>NodeList.prototype.keys(),NodeList.prototype.values(),NodeList.prototype.entries()</h2><p><strong>这三个方法都返回一个 ES6 的遍历器对象，可以通过<code>for...of</code>循环遍历获取每一个成员的信息。区别在于，<code>keys()</code>返回键名的遍历器，<code>values()</code>返回键值的遍历器，<code>entries()</code>返回的遍历器同时包含键名和键值的信息。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> children.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> children.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #text</span></span><br><span class="line"><span class="comment">// &lt;script&gt;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry <span class="keyword">of</span> children.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ 0, #text ]</span></span><br><span class="line"><span class="comment">// Array [ 1, &lt;script&gt; ]</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><strong>for…in 和 for…of 的区别是for…in 获取的是属性，for…of获取的是值。</strong></p>
<h1 id="HTMLCollection接口"><a href="#HTMLCollection接口" class="headerlink" title="HTMLCollection接口"></a>HTMLCollection接口</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong><code>HTMLCollection</code>是一个节点对象的集合，只能包含元素节点（element</strong>），不能包含其他类型的节点。<strong><u>它的返回值是一个类似数组的对象，但是与<code>NodeList</code>接口不同，<code>HTMLCollection</code>没有<code>forEach</code>方法，只能使用<code>for</code>循环遍历。</u></strong></p>
<p>返回<code>HTMLCollection</code>实例的，<strong>主要是一些<code>Document</code>对象的集合属性，比如<code>document.links</code>、<code>document.forms</code>、<code>document.images</code>等。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.links <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>HTMLCollection</code>实例都是动态集合，节点的变化会实时反映在集合中。</p>
<p><strong>如果元素节点有<code>id</code>或<code>name</code>属性，那么<code>HTMLCollection</code>实例上面，可以使用<code>id</code>属性或<code>name</code>属性引用该节点元素。如果没有对应的节点，则返回<code>null</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="built_in">document</span>.getElementById(<span class="string">'pic'</span>);</span><br><span class="line"><span class="built_in">document</span>.images.pic === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document.images</code>是一个<code>HTMLCollection</code>实例，可以通过<code>&lt;img&gt;</code>元素的<code>id</code>属性值，从<code>HTMLCollection</code>实例上取到这个元素。</p>
<h2 id="HTMLConllection-prototype-length属性返回HTMLCollection实例包含的成员数量。"><a href="#HTMLConllection-prototype-length属性返回HTMLCollection实例包含的成员数量。" class="headerlink" title="HTMLConllection.prototype.length属性返回HTMLCollection实例包含的成员数量。"></a>HTMLConllection.prototype.length属性返回<code>HTMLCollection</code>实例包含的成员数量。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.links.length <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<h2 id="HTMLConllection-prototype-item-方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"><a href="#HTMLConllection-prototype-item-方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员" class="headerlink" title="HTMLConllection.prototype.item()方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员"></a>HTMLConllection.prototype.item()方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.images;</span><br><span class="line"><span class="keyword">var</span> img0 = c.item(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>item(0)</code>表示返回0号位置的成员。由于方括号运算符也具有同样作用，而且使用更方便，所以一般情况下，总是使用方括号运算符。</p>
<p>如果参数值超出成员数量或者不合法（比如小于0），那么<code>item</code>方法返回<code>null</code>。</p>
<h2 id="HTMLConllection-prototype-namedItem-方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。"><a href="#HTMLConllection-prototype-namedItem-方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。" class="headerlink" title="HTMLConllection.prototype.namedItem()方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。"></a>HTMLConllection.prototype.namedItem()方法的参数是一个字符串，表示<code>id</code>属性或<code>name</code>属性的值，返回对应的元素节点。如果没有对应的节点，则返回<code>null</code>。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;img id="pic" src="http://example.com/foo.jpg"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pic = <span class="built_in">document</span>.getElementById(<span class="string">'pic'</span>);</span><br><span class="line"><span class="built_in">document</span>.images.namedItem(<span class="string">'pic'</span>) === pic <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="ParentNode接口"><a href="#ParentNode接口" class="headerlink" title="ParentNode接口"></a>ParentNode接口</h1><p><strong>节点对象除了继承 Node 接口以外，还会继承其他接口。<code>ParentNode</code>接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code>ChildNode</code>接口表示当前节点是一个子节点，提供一些相关方法。</strong></p>
<p>如果当前节点是父节点，就会继承<code>ParentNode</code>接口。<strong>由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承<code>ParentNode</code>接口。</strong></p>
<h2 id="ParentNode-children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。"><a href="#ParentNode-children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。" class="headerlink" title="ParentNode.children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。"></a>ParentNode.children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</h2><p>下面是遍历某个节点的某个点的所有元素节点的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>children</code>属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值<code>HTMLCollection</code>实例的<code>length</code>属性为<code>0</code>。</p>
<p><strong>另外，<code>HTMLCollection</code>是动态集合，会实时反映 DOM 的任何变化。</strong></p>
<h2 id="ParentNode-firstElementChild-属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null"><a href="#ParentNode-firstElementChild-属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null" class="headerlink" title="ParentNode.firstElementChild()属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null"></a>ParentNode.firstElementChild()属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.firstElementChild.nodeName</span><br><span class="line"><span class="comment">// "HTML"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>document</code>节点的第一个元素子节点是<code>&lt;HTML&gt;</code>（因为<code>document</code>只包含这一个元素子节点）。</p>
<h2 id="ParentNode-childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。"><a href="#ParentNode-childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。" class="headerlink" title="ParentNode.childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。"></a>ParentNode.childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回<code>0</code>。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childElementCount <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<h2 id="ParentNode-append-ParentNode-prepend"><a href="#ParentNode-append-ParentNode-prepend" class="headerlink" title="ParentNode.append(),ParentNode.prepend()"></a>ParentNode.append(),ParentNode.prepend()</h2><p><strong><code>append</code>方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</strong> <strong>该方法不仅可以添加元素子节点，还可以添加文本子节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.body;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文本子节点</span></span><br><span class="line">parent.append(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点和文本子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(<span class="string">'Hello'</span>, p);</span><br></pre></td></tr></table></figure>
<p>注意，该方法没有返回值。</p>
<p><strong><code>prepend</code>方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与<code>append</code>方法完全一致，也是没有返回值。</strong></p>
<h4 id="append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。"><a href="#append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。" class="headerlink" title="append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。"></a>append方法和appendChild方法的区别是，append方法的参数可以是字符串，appendChild方法不能是（否则报错）。append方法一次可以插入多个节点，而appendChild方法一次只能插入一个节点。</h4><h1 id="ChildNode接口"><a href="#ChildNode接口" class="headerlink" title="ChildNode接口"></a>ChildNode接口</h1><p><strong>如果一个节点有父节点，那么该节点就继承了ChildNode接口。</strong></p>
<h2 id="ChildNode-remove"><a href="#ChildNode-remove" class="headerlink" title="ChildNode.remove()"></a>ChildNode.remove()</h2><p>remove方法用于从父节点移除当前节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure>
<p>上面代码在 DOM 里面移除了<code>el</code>节点。</p>
<h2 id="ChildNode-before-ChildNode-after"><a href="#ChildNode-before-ChildNode-after" class="headerlink" title="ChildNode.before(),ChildNode.after()"></a>ChildNode.before(),ChildNode.after()</h2><p><strong><u><code>before</code>方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</u></strong></p>
<p><strong>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点</span></span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本节点</span></span><br><span class="line">el.before(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入多个元素节点</span></span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点和文本节点</span></span><br><span class="line">el.before(p, <span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure>
<p><strong><code>after</code>方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与<code>before</code>方法完全相同。</strong></p>
<h2 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h2><p><strong><code>replaceWith</code>方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>el</code>节点将被<code>span</code>节点替换。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-04T05:29:49.835Z" itemprop="dateUpdated">2019-08-04 13:29:49</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/08/02/JS学习之DOM概述/" target="_blank" rel="external">http://hedroins.github.io/2019/08/02/JS学习之DOM概述/</a>
        
    </div>
    
    <footer>
        <a href="http://hedroins.github.io">
            <img src="/img/avatar.jpg" alt="HeJL">
            HeJL
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DOM概述/">DOM概述</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&title=《JS学习之DOM概述》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&title=《JS学习之DOM概述》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之DOM概述》 — HeJL&url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/04/JS学习之Document对象/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JS学习之Document对象</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/08/01/JS学习之严格模式/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JS学习之严格模式</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>HeJL &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&title=《JS学习之DOM概述》 — HeJL&pic=http://hedroins.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&title=《JS学习之DOM概述》 — HeJL&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JS学习之DOM概述》 — HeJL&url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/&via=http://hedroins.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://hedroins.github.io/2019/08/02/JS学习之DOM概述/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
